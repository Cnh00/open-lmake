#!/bin/bash -ex

# This file is part of the lmake distribution (git@github.com:cesar-douady/open-lmake.git)
# Copyright (c) 2023 Doliam
# This program is free software: you can redistribute/modify under the terms of the GPL-v3 (https://www.gnu.org/licenses/gpl-3.0.html).
# This program is distributed WITHOUT ANY WARRANTY, without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.

unset CDPATH                                                                   # ensure cd goes to the right directory and writes nothing to stdout

mkdir -p trial
cd       trial

#
# HAS_SECCOMP
# test whether we have seccomp : warning, include <seccomp.h> is not enough to test, check its content too
#
cat <<"EOF" > seccomp.c
	#include<seccomp.h>
	struct scmp_version v ;
EOF
# usually seccomp.h is in /usr/include (with an internal file /usr/include/linux/seccompt.h) but some systems have seccomp.h directly installed in /usr/include/linux
if $CC -c -idirafter /usr/include/linux -o ptrace.o seccomp.c
then HAS_SECCOMP=1
else HAS_SECCOMP=0
fi

#
# HAS_PTRACE_GET_SYSCALL_INFO
#
cat <<"EOF" > get_syscall_info.c
	#include<sys/ptrace.h>
	#include<linux/ptrace.h>
	void foo() {
		long rx = ptrace(PTRACE_GET_SYSCALL_INFO,0,0,0) ;
	}
EOF
if $CC -c -idirafter /usr/include/linux -o get_syscall_info.o get_syscall_info.c
then HAS_PTRACE_GET_SYSCALL_INFO=1
else HAS_PTRACE_GET_SYSCALL_INFO=0
fi

#
# HAS_CLOSE_RANGE
# test whether we can include linux/close_range.h
#
if $CC -E --include 'linux/close_range.h' -xc - </dev/null >/dev/null 2>/dev/null
then HAS_CLOSE_RANGE=1
else HAS_CLOSE_RANGE=0
fi

#
# HAS_LD_AUDIT
# test whether LD_AUDIT environment variable is managed by dynamic linker
#
cat <<"EOF" > audited.c
	#include<stdio.h>
	int main() { printf("0") ; }
EOF
cat <<"EOF" > ld_audit.c
	#include<stdio.h>
	#include<stdlib.h>
	unsigned int la_version(unsigned int) { printf("1") ; exit(0) ; }
EOF
$CC -o audited                   audited.c
$CC -o ld_audit.so -shared -fPIC ld_audit.c
HAS_LD_AUDIT=$(LD_AUDIT=./ld_audit.so ./audited)
# CentOS7 fix : This is what would answer a real centos-7 system, but we may be running in a docker which has a more recent kernel.
grep -q 'release 7' /etc/redhat-release 2>/dev/null && HAS_LD_AUDIT=0

#
# NEED_STAT_WRAPPERS
# test whether stat syscalls are transformed into __xstat
#
cat <<"EOF" > stat.c
	#include <sys/stat.h>
	struct stat buf ;
	int main() { stat("",&buf) ; }
EOF
$CC -o stat_trial stat.c
if nm -D stat_trial | grep -wq stat
then NEED_STAT_WRAPPERS=0
else NEED_STAT_WRAPPERS=1
fi

#
# HAS_OSTRINGSTREAM_VIEW
# test whether std::ostringstream has method view()
#
cat <<"EOF" > ostringstream_view.cc
	#include <sstream>
	std::string_view ossv = std::ostringstream().view() ;
EOF
if $CC -c -std=c++20 -o ostringstream_view.o ostringstream_view.cc 2>/dev/null
then HAS_OSTRINGSTREAM_VIEW=1
else HAS_OSTRINGSTREAM_VIEW=0
fi

#
# HAS_SLURM
#
if $CC -E --include slurm/slurm.h -xc - </dev/null >/dev/null 2>/dev/null
then HAS_SLURM=1
else HAS_SLURM=0
fi

#
# LD_LIBRARY_PATH for python
# in current LD_LIBRARY_PATH, at most one entry is necessary to run python, this is the only one we are interested in
#
if LD_LIBRARY_PATH= $PYTHON </dev/null ; then
	PYTHON_LD_LIBRARY_PATH=
else
	for PYTHON_LD_LIBRARY_PATH in ${LD_LIBRARY_PATH//:/ } ; do
		LD_LIBRARY_PATH=$PYTHON_LD_LIBRARY_PATH $PYTHON</dev/null && break
	done
fi

cat <<EOF
	#define HAS_CLOSE_RANGE             $HAS_CLOSE_RANGE
	#define HAS_SECCOMP                 $HAS_SECCOMP
	#define HAS_PTRACE_GET_SYSCALL_INFO $HAS_PTRACE_GET_SYSCALL_INFO
	#define HAS_LD_AUDIT                $HAS_LD_AUDIT
	#define NEED_STAT_WRAPPERS          $NEED_STAT_WRAPPERS
	#define HAS_OSTRINGSTREAM_VIEW      $HAS_OSTRINGSTREAM_VIEW
	#define HAS_SLURM                   $HAS_SLURM
	#define PYTHON                      "$PYTHON"
	#define PYTHON_LD_LIBRARY_PATH      "$PYTHON_LD_LIBRARY_PATH"
EOF
