// This file is part of the open-lmake distribution (git@github.com:cesar-douady/open-lmake.git)
// Copyright (c) 2023 Doliam
// This program is free software: you can redistribute/modify under the terms of the GPL-v3 (https://www.gnu.org/licenses/gpl-3.0.html).
// This program is distributed WITHOUT ANY WARRANTY, without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.

#include "app.hh"

#include "record.hh"

#include "rpc_job.hh"

ENUM(Key,None)
ENUM(Flag
,	Essential
,	Incremental
,	Phony
,	SourceOk
,	NoUniquify
,	NoWarning
,	ReadIsDep
,	NoAllow
,	NoFollow
,	Unlink
)

int main( int argc , char* argv[]) {
	Syntax<Key,Flag> syntax{{
		{ Flag::NoFollow    , { .short_name='P'                             , .has_arg=false , .doc="Physical view, do not follow symbolic links."                           } }
	,	{ Flag::Unlink      , { .short_name='U'                             , .has_arg=false , .doc="report an unlink"                                                       } }
	//
	,	{ Flag::Essential   , { .short_name=TflagChars[+Tflag::Essential  ] , .has_arg=false , .doc="show when generating user oriented graphs"                              } }
	,	{ Flag::Incremental , { .short_name=TflagChars[+Tflag::Incremental] , .has_arg=false , .doc="do not rm file before job execution"                                    } }
	,	{ Flag::Phony       , { .short_name=TflagChars[+Tflag::Phony      ] , .has_arg=false , .doc="accept that target is not physically generated on disk"                 } }
	,	{ Flag::NoUniquify  , { .short_name=TflagChars[+Tflag::NoUniquify ] , .has_arg=false , .doc="do not uniquify target if incremental and several links point to it"    } }
	,	{ Flag::NoWarning   , { .short_name=TflagChars[+Tflag::NoWarning  ] , .has_arg=false , .doc="do not warn user if uniquified or rm'ed while generated by another job" } }
	,	{ Flag::SourceOk    , { .short_name='s'                             , .has_arg=false , .doc="accept if target is actually a source"                                  } }
	,	{ Flag::ReadIsDep   , { .short_name='d'                             , .has_arg=false , .doc="if file is only read, it is processed as a dep, not a target"           } }
	,	{ Flag::NoAllow     , { .short_name='a'                             , .has_arg=false , .doc="do not force target to be accepted, just inform writing to it"          } }
	}} ;
	CmdLine<Key,Flag> cmd_line { syntax,argc,argv } ;
	//
	if (!cmd_line.args) return 0 ;                                                                         // fast path : declare no targets
	for( ::string const& f : cmd_line.args ) if (!f) syntax.usage("cannot declare empty file as target") ;
	//
	AccessDigest ad        { .write=Yes } ;
	bool         no_follow = cmd_line.flags[Flag::NoFollow] ;
	//
	if (cmd_line.flags[Flag::Unlink]) ad.write = Maybe ;
	//
	if ( cmd_line.flags[Flag::Essential  ]) ad.tflags       |= Tflag     ::Essential   ;
	if ( cmd_line.flags[Flag::Incremental]) ad.tflags       |= Tflag     ::Incremental ;
	if ( cmd_line.flags[Flag::Phony      ]) ad.tflags       |= Tflag     ::Phony       ;
	if ( cmd_line.flags[Flag::NoUniquify ]) ad.tflags       |= Tflag     ::NoUniquify  ;
	if ( cmd_line.flags[Flag::NoWarning  ]) ad.tflags       |= Tflag     ::NoWarning   ;
	if ( cmd_line.flags[Flag::SourceOk   ]) ad.extra_tflags |= ExtraTflag::SourceOk    ;
	if ( cmd_line.flags[Flag::ReadIsDep  ]) ad.extra_tflags |= ExtraTflag::ReadIsDep   ;
	if (!cmd_line.flags[Flag::NoAllow    ]) ad.extra_tflags |= ExtraTflag::Allow       ;
	//
	Record record{New} ;
	JobExecRpcReq jerr { JobExecRpcProc::Access  , ::move(cmd_line.args) , ad , no_follow , false/*sync*/ , "ltarget" } ;
	jerr.confirm = Yes ;
	record.direct(::move(jerr)) ;
	//
	return 0 ;
}
