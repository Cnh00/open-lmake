// This file is part of the open-lmake distribution (git@github.com:cesar-douady/open-lmake.git)
// Copyright (c) 2023 Doliam
// This program is free software: you can redistribute/modify under the terms of the GPL-v3 (https://www.gnu.org/licenses/gpl-3.0.html).
// This program is distributed WITHOUT ANY WARRANTY, without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.

#pragma once

#include "config.hh"

#include "disk.hh"
#include "hash.hh"
#include "serialize.hh"
#include "time.hh"

#include "autodep/env.hh"

ENUM_1( BackendTag // PER_BACKEND : add a tag for each backend
,	Dflt = Local
,	Local
,	Slurm
,	Unknown
)

ENUM_1( FileActionTag
,	HasFile = Uniquify // <=HasFile means action acts on file
,	None               // no action, just check integrity
,	Src                // file is src, no action
,	Unlink
,	Uniquify
,	Mkdir
,	Rmdir
)
struct FileAction {
	friend ::ostream& operator<<( ::ostream& , FileAction const& ) ;
	FileActionTag tag  = {} ;
	Hash::Crc     crc  ;
	Disk::Ddate   date ;
} ;
::pair<vector_s/*unlinks*/,pair_s<bool/*ok*/>/*msg*/> do_file_actions( ::vmap_s<FileAction>&& pre_actions , Disk::NfsGuard& nfs_guard , Algo ) ;

ENUM_2( Dflag                          // flags for deps
,	NRule = Required                   // number of Dflag's allowed in rule definition
,	NDyn  = Static                     // number of Dflag's allowed in lside flags
	//
,	Essential                          // show when generating user oriented graphs
,	Critical                           // if modified, ignore following deps
,	IgnoreError                        // dont propagate error if dep is in error (Error instead of Err because name is visible from user)
,	Required                           // dep must be buildable
,	Static                             // is static dep, for internal use only
)
static constexpr char DflagChars[] = {
	'E'                                // Essential
,	'c'                                // Critical
,	'e'                                // IgnoreError
,	'r'                                // Required
,	'S'                                // Static
} ;
static_assert(::size(DflagChars)==N<Dflag>) ;
using Dflags = BitMap<Dflag> ;

ENUM_1( ExtraDflag
,	NDep = Ignore                           // number of ExtraDflag's allowed in rule definition
,	Top
,	Ignore
,	StatReadData
)
static constexpr char ExtraDflagChars[] = {
	'/'                                     // Top
,	'd'                                     // StatReadData
,	'i'                                     // Ignore
} ;
static_assert(::size(ExtraDflagChars)==N<ExtraDflag>) ;
using ExtraDflags = BitMap<ExtraDflag> ;

ENUM_2( Tflag                          // flags for targets
,	NRule = Static                     // number of Tflag's allowed in rule definition
,	NDyn  = Static                     // number of Tflag's allowed inlside flags
,	Essential                          // show when generating user oriented graphs
,	Incremental                        // reads are allowed (before earliest write if any)
,	Phony                              // accept that target is not generated
,	SourceOk                           // ok to overwrite manual files (including sources)
,	NoUniquify                         // target is uniquified if it has several links and is incremental
,	NoWarning                          // warn if target is either uniquified or unlinked and generated by another rule
,	Static                             // is static  , for internal use only
,	Target                             // is a target, for internal use only
)
static constexpr char TflagChars[] = {
	'E'                                // Essential
,	'i'                                // Incremental
,	'p'                                // Phony
,	's'                                // SourceOk
,	'u'                                // NoUniquify
,	'w'                                // NoWarning
,	'S'                                // Static
,	'T'                                // Target
} ;
static_assert(::size(TflagChars)==N<Tflag>) ;
using Tflags = BitMap<Tflag> ;

ENUM( ExtraTflag
,	Top
,	ReadIsDep                               // target is transform into dep if accessed read-only
)
static constexpr char ExtraTflagChars[] = {
	'/'                                     // Top
,	'd'                                     // ReadIsDep
} ;
static_assert(::size(ExtraDflagChars)==N<ExtraDflag>) ;
using ExtraTflags = BitMap<ExtraTflag> ;

ENUM( JobProc
,	None
,	Start
,	ReportStart
,	GiveUp      // Req (all if 0) was killed and job was not (either because of other Req's or it did not start yet)
,	ChkDeps
,	DepInfos
,	Decode
,	Encode
,	LiveOut
,	End
)

ENUM_2( JobReasonTag                                // see explanations in table below
,	HasNode = ClashTarget                           // if >=HasNode, a node is associated
,	Err     = DepErr                                // if >=Err, job did not complete because of a dep
	//
,	None
//	with reason
,	ChkDeps
,	Cmd
,	Force
,	Garbage
,	Killed
,	Lost
,	New
,	OldErr
,	Rsrcs
//	with node
,	ClashTarget
,	DepChanged
,	DepUnstable
,	DepNotReady
,	DepOutOfDate
,	NoTarget
,	PollutedTarget
,	PrevTarget
//	with error
,	DepErr
,	DepMissingStatic
,	DepMissingRequired
,	DepOverwritten
)
static constexpr const char* JobReasonTagStrs[] = {
	"no reason"                                     // None
//	with reason
,	"dep check requires rerun"                      // ChkDeps
,	"command changed"                               // Cmd
,	"job forced"                                    // Force
,	"job ran with unstable data"                    // Garbage
,	"job was killed"                                // Killed
,	"job was lost"                                  // Lost
,	"job was never run"                             // New
,	"job was in error"                              // OldErr
,	"resources changed and job was in error"        // Rsrcs
//	with node
,	"multiple simultaneous writes"                  // ClashTarget
,	"dep changed"                                   // DepChanged
,	"dep unstable"                                  // DepUnstable
,	"dep not ready"                                 // DepNotReady
,	"dep out of date"                               // DepOutOfDate
,	"missing target"                                // NoTarget
,	"polluted target"                               // PollutedTarget
,	"target previously existed"                     // PrevTarget
//	with error
,	"dep in error"                                  // DepErr
,	"static dep missing"                            // DepMissingStatic
,	"required dep missing"                          // DepMissingRequired
,	"dep has been overwritten"                      // DepOverwritten
} ;
static_assert(::size(JobReasonTagStrs)==N<JobReasonTag>) ;

ENUM( MatchKind
,	Target
,	TargetFlags
,	DepFlags
)

ENUM_2( Status           // result of job execution
,	Early = EarlyLostErr // <=Early means output has not been modified
,	Async = Killed       // <=Async means job was interrupted asynchronously
,	New                  // job was never run
,	Manual               // job was not started because some targets were manual
,	EarlyErr             // job was not started because of error
,	EarlyLost            // job was lost before starting     , retry
,	EarlyLostErr         // job was lost before starting     , do not retry
,	LateLost             // job was lost after having started, retry
,	LateLostErr          // job was lost after having started, do not retry
,	Killed               // job was killed
,	ChkDeps              // dep check failed
,	Garbage              // <=Garbage means job has not run reliably
,	Ok                   // job execution ended successfully
,	Err                  // job execution ended in error
)
static inline bool  is_lost(Status s) { return s<=Status::LateLostErr && s>=Status::EarlyLost ; }
static inline Bool3 is_ok  (Status s) {
	switch (s) {
		case Status::New          : return Maybe ;
		case Status::Manual       : return No    ;
		case Status::EarlyErr     : return No    ;
		case Status::EarlyLost    : return Maybe ;
		case Status::EarlyLostErr : return No    ;
		case Status::LateLost     : return Maybe ;
		case Status::LateLostErr  : return No    ;
		case Status::Killed       :
		case Status::ChkDeps      :
		case Status::Garbage      : return Maybe ;
		case Status::Ok           : return Yes   ;
		case Status::Err          : return No    ;
	DF}
}
static inline Status mk_err(Status s) {
	switch (s) {
		case Status::New       : return Status::EarlyErr     ;
		case Status::EarlyLost : return Status::EarlyLostErr ;
		case Status::LateLost  : return Status::LateLostErr  ;
		case Status::Ok        : return Status::Err          ;
	DF}
}

static const ::string EnvPassMrkr = {'\0','p'} ; // special illegal value to ask for value from environment
static const ::string EnvDynMrkr  = {'\0','d'} ; // special illegal value to mark dynamically computed env variables

static constexpr char QuarantineDirS[] = ADMIN_DIR "/quarantine/" ;

struct AccDflags {
	// services
	AccDflags  operator| (AccDflags other) const { return { accesses|other.accesses , dflags|other.dflags } ; }
	AccDflags& operator|=(AccDflags other)       { *this = *this | other ; return *this ;                     }
	// data
	Accesses accesses ;
	Dflags   dflags   ;
} ;

struct JobReason {
	friend ::ostream& operator<<( ::ostream& , JobReason const& ) ;
	using Tag = JobReasonTag ;
	// cxtors & casts
	JobReason(                   ) = default ;
	JobReason( Tag t             ) : tag{t}           { SWEAR( t< Tag::HasNode       , t     ) ; }
	JobReason( Tag t , NodeIdx n ) : tag{t} , node{n} { SWEAR( t>=Tag::HasNode && +n , t , n ) ; }
	// accesses
	bool operator+() const { return +tag ; }
	bool operator!() const { return !tag ; }
	// services
	JobReason operator|(JobReason jr) const {
		if (   tag>=Tag::Err    ) return *this ;
		if (jr.tag>=Tag::Err    ) return jr    ;
		if (   tag>=Tag::HasNode) return *this ;
		if (jr.tag>=Tag::HasNode) return jr    ;
		if (+*this              ) return *this ;
		/**/                      return jr    ;
	}
	JobReason& operator|=(JobReason jr) { *this = *this | jr ; return *this ; }
	::string msg() const {
		if (tag<Tag::HasNode) SWEAR(node==0,tag,node) ;
		return JobReasonTagStrs[+tag] ;
	}

	// data
	Tag     tag  = JobReasonTag::None ;
	NodeIdx node = 0                  ;
} ;

struct SubmitAttrs {
	friend ::ostream& operator<<( ::ostream& , SubmitAttrs const& ) ;
	// services
	SubmitAttrs& operator|=(SubmitAttrs const& other) {
		if      (      tag==BackendTag::Unknown) tag = other.tag ;
		else if (other.tag!=BackendTag::Unknown) SWEAR(tag==other.tag,tag,other.tag) ;
		SWEAR( !n_retries || !other.n_retries || n_retries==other.n_retries , n_retries , other.n_retries ) ; // n_retries does not depend on req, but may not always be present
		n_retries  = ::max(n_retries,other.n_retries) ;
		pressure   = ::max(pressure ,other.pressure ) ;
		live_out  |= other.live_out                   ;
		reason    |= other.reason                     ;
		return *this ;
	}
	SubmitAttrs operator|(SubmitAttrs const& other) const {
		SubmitAttrs res = *this ;
		res |= other ;
		return res ;
	}
	// data
	BackendTag        tag       = BackendTag::Unknown ;
	bool              live_out  = false               ;
	uint8_t           n_retries = 0                   ;
	Time::CoarseDelay pressure  = {}                  ;
	JobReason         reason    = {}                  ;
} ;

struct JobStats {
	using Delay = Time::Delay ;
	// data
	Delay  cpu   = {} ;
	Delay  job   = {} ; // elapsed in job
	Delay  total = {} ; // elapsed including overhead
	size_t mem   = 0  ; // in bytes
} ;

// for Dep recording in book-keeping, we want to derive from Node
// but if we derive from Node and have a field DepDigest, it is impossible to have a compact layout because of alignment constraints
// hence this solution : derive from a template argument
template<class B> struct DepDigestBase ;
template<class B> ::ostream& operator<<( ::ostream& , DepDigestBase<B> const& ) ;
template<class B> struct DepDigestBase : NoVoid<B> {
	friend ::ostream& operator<< <>( ::ostream& , DepDigestBase const& ) ;
	using Base = NoVoid<B> ;
	static constexpr bool HasBase = !::is_same_v<B,void> ;
	//
	using Tag   = FileTag     ;
	using Crc   = Hash::Crc   ;
	using Ddate = Time::Ddate ;
	//cxtors & casts
	DepDigestBase(                                                 bool p=false ) :                                       parallel{p} , _crc{} {           }
	DepDigestBase(          Accesses a ,           Dflags dfs={} , bool p=false ) :           dflags(dfs) , accesses{a} , parallel{p} , _crc{} {           }
	DepDigestBase(          Accesses a , Crc   c , Dflags dfs={} , bool p=false ) :           dflags(dfs) , accesses{a} , parallel{p}          { crc (c) ; }
	DepDigestBase(          Accesses a , Ddate d , Dflags dfs={} , bool p=false ) :           dflags(dfs) , accesses{a} , parallel{p}          { date(d) ; }
	DepDigestBase( Base b , Accesses a ,           Dflags dfs={} , bool p=false ) : Base{b} , dflags(dfs) , accesses{a} , parallel{p} , _crc{} {           }
	DepDigestBase( Base b , Accesses a , Crc   c , Dflags dfs={} , bool p=false ) : Base{b} , dflags(dfs) , accesses{a} , parallel{p}          { crc (c) ; }
	DepDigestBase( Base b , Accesses a , Ddate d , Dflags dfs={} , bool p=false ) : Base{b} , dflags(dfs) , accesses{a} , parallel{p}          { date(d) ; }
	//
	template<class B2> DepDigestBase(          DepDigestBase<B2> const& dd ) :           dflags(dd.dflags) , accesses{dd.accesses} , parallel{dd.parallel} { crc_date(dd) ; }
	template<class B2> DepDigestBase( Base b , DepDigestBase<B2> const& dd ) : Base{b} , dflags(dd.dflags) , accesses{dd.accesses} , parallel{dd.parallel} { crc_date(dd) ; }
	//
	bool operator==(DepDigestBase const& other) const {
		if (dflags  !=other.dflags  ) return false              ;
		if (accesses!=other.accesses) return false              ;
		if (parallel!=other.parallel) return false              ;
		if (is_date !=other.is_date ) return false              ;
		if (is_date                 ) return _date==other._date ;
		else                          return _crc ==other._crc  ;
	}
	// accesses
	#pragma GCC diagnostic push                                                  // gcc-11 is lost with union management
	#pragma GCC diagnostic ignored "-Wmaybe-uninitialized"
	Crc   crc () const { SWEAR( +accesses && !is_date , accesses , is_date ) ; return _crc  ; }
	Ddate date() const { SWEAR( +accesses &&  is_date , accesses , is_date ) ; return _date ; }
	#pragma GCC diagnostic pop
	//
	void crc (Crc   c) { is_date = false ; _crc  = c  ; }
	void date(Ddate d) { is_date = true  ; _date = d  ; }
	template<class B2> void crc_date(DepDigestBase<B2> const& dd) {
		if (!dd.accesses) return ;
		if ( dd.is_date ) date(dd.date()) ;
		else              crc (dd.crc ()) ;
	}
	// services
	void tag(Tag tag) {
		SWEAR(is_date) ;
		if (!_date) { crc(Crc::None) ; return ; }                                // even if file appears, the whole job has been executed seeing the file as absent
		switch (tag) {
			case Tag::Reg  :
			case Tag::Exe  :
			case Tag::Lnk  : if (!Crc::s_sense(accesses,tag)) crc(tag) ; break ; // just record the tag if enough to match (e.g. accesses==Lnk and tag==Reg)
			case Tag::None :
			case Tag::Dir  : if (+_date                     ) crc({} ) ; break ;
			case Tag::Err  :                                  crc({} ) ; break ; // if we dont know what we access, we cannot know the crc
		}
	}
	// data
	Dflags   dflags     ;                                                        //   6< 8 bits
	Accesses accesses   ;                                                        //   3< 8 bits
	bool     parallel:1 = false ;                                                //      1 bit
	bool     is_date :1 = false ;                                                //      1 bit
private :
	union {
		Crc   _crc  ;                                                            // ~46<64 bits
		Ddate _date ;                                                            // ~45<64 bits
	} ;
} ;
template<class B> ::ostream& operator<<( ::ostream& os , DepDigestBase<B> const& dd ) {
	const char* sep = "" ;
	/**/                                                os << "D("                           ;
	if constexpr ( !::is_void_v<B>                  ) { os <<sep<< static_cast<B const&>(dd) ; sep = "," ; }
	if           ( +dd.accesses                     ) { os <<sep<< dd.accesses               ; sep = "," ; }
	if           ( +dd.dflags                       ) { os <<sep<< dd.dflags                 ; sep = "," ; }
	if           (  dd.parallel                     ) { os <<sep<< "parallel"                ; sep = "," ; }
	if           ( +dd.accesses && dd.is_date       ) { os <<sep<< dd.date()                 ; sep = "," ; }
	else if      ( +dd.accesses && +dd.crc()        ) { os <<sep<< dd.crc()                  ; sep = "," ; }
	return                                              os <<')'                             ;
}

using DepDigest = DepDigestBase<void> ;
static_assert(::is_trivially_copyable_v<DepDigest>) ; // as long as this holds, we do not have to bother about union member cxtor/dxtor

struct TargetDigest {
	friend ::ostream& operator<<( ::ostream& , TargetDigest const& ) ;
	using Crc = Hash::Crc ;
	// data
	Accesses    accesses = {}               ; // how target was accessed before it was written
	Tflags      tflags   = {}               ;
	bool        write    = false/*garbage*/ ; // if true <=> file was written (and possibly further unlinked)
	Crc         crc      = {}   /*garbage*/ ; // if None <=> file was unlinked, if Unknown <=> file is idle (not written, not unlinked)
	Time::Ddate date     = {}               ;
} ;

struct JobDigest {
	friend ::ostream& operator<<( ::ostream& , JobDigest const& ) ;
	// data
	Status                 status   = Status::New ;
	::vmap_s<TargetDigest> targets  = {}          ;
	::vmap_s<DepDigest   > deps     = {}          ; // INVARIANT : sorted in first access order
	::string               stderr   = {}          ;
	::string               stdout   = {}          ;
	int                    wstatus  = 0           ;
	Time::Pdate            end_date = {}          ;
	JobStats               stats    = {}          ;
} ;

struct JobExecRpcReq ;

struct JobRpcReq {
	using P   = JobProc             ;
	using SI  = SeqId               ;
	using JI  = JobIdx              ;
	using MDD = ::vmap_s<DepDigest> ;
	friend ::ostream& operator<<( ::ostream& , JobRpcReq const& ) ;
	// statics
	// cxtors & casts
	JobRpcReq() = default ;
	JobRpcReq( P p , SI si , JI j                                    ) : proc{p} , seq_id{si} , job{j}                                             { SWEAR( p==P::None                      ) ; }
	JobRpcReq( P p , SI si , JI j , in_port_t   pt , ::string&& m={} ) : proc{p} , seq_id{si} , job{j} , port  {pt              } , msg{::move(m)} { SWEAR( p==P::Start                     ) ; }
	JobRpcReq( P p , SI si , JI j , Status      s  , ::string&& m={} ) : proc{p} , seq_id{si} , job{j} , digest{.status=s       } , msg{::move(m)} { SWEAR( p==P::End && s<=Status::Garbage ) ; }
	JobRpcReq( P p , SI si , JI j , JobDigest&& d  , ::string&& m={} ) : proc{p} , seq_id{si} , job{j} , digest{::move(d)       } , msg{::move(m)} { SWEAR( p==P::End                       ) ; }
	JobRpcReq( P p , SI si , JI j ,                  ::string&& m    ) : proc{p} , seq_id{si} , job{j} ,                            msg{::move(m)} { SWEAR( p==P::LiveOut                   ) ; }
	JobRpcReq( P p , SI si , JI j , MDD&&       ds                   ) : proc{p} , seq_id{si} , job{j} , digest{.deps=::move(ds)}                  { SWEAR( p==P::ChkDeps || p==P::DepInfos ) ; }
	//
	JobRpcReq( P p , SI si , JI j , ::string&& code , ::string&& f , ::string&& c              ) : proc{p} , seq_id{si} , job{j} , msg{code} , file{f} , ctx{c}               { SWEAR(p==P::Decode) ; }
	JobRpcReq( P p , SI si , JI j , ::string&& val  , ::string&& f , ::string&& c , uint8_t ml ) : proc{p} , seq_id{si} , job{j} , msg{val } , file{f} , ctx{c} , min_len{ml} { SWEAR(p==P::Encode) ; }
	//
	JobRpcReq( SI si , JI j , JobExecRpcReq&& jerr ) ;
	// services
	template<IsStream T> void serdes(T& s) {
		if (::is_base_of_v<::istream,T>) *this = JobRpcReq() ;
		::serdes(s,proc  ) ;
		::serdes(s,seq_id) ;
		::serdes(s,job   ) ;
		switch (proc) {
			case P::None  : break ;
			case P::Start :
				::serdes(s,port) ;
				::serdes(s,msg ) ;
			break ;
			case P::LiveOut  : ::serdes(s,msg   ) ; break ;
			case P::ChkDeps  : ::serdes(s,digest) ; break ;
			case P::DepInfos : ::serdes(s,digest) ; break ;
			case P::Encode :
				::serdes(s,min_len) ;
				[[fallthrough]] ;
			case P::Decode :
				::serdes(s,msg ) ;
				::serdes(s,file) ;
				::serdes(s,ctx ) ;
			break ;
			case P::End :
				::serdes(s,digest) ;
				::serdes(s,msg   ) ;
			break ;
		DF}
	}
	// data
	P         proc    = P::None ;
	SI        seq_id  = 0       ;
	JI        job     = 0       ;
	in_port_t port    = 0       ; // if proc == Start
	JobDigest digest  ;           // if proc ==         ChkDeps | DepInfos |                              End
	::string  msg     ;           // if proc == Start |                      LiveOut  | Decode | Encode | End
	::string  file    ;           // if proc ==                                         Decode | Encode
	::string  ctx     ;           // if proc ==                                         Decode | Encode
	uint8_t   min_len ;           // if proc ==                                                  Encode
} ;

struct MatchFlags {
	friend ::ostream& operator<<( ::ostream& , MatchFlags const& ) ;
	// cxtors & casts
	MatchFlags(                             ) = default ;
	MatchFlags( Tflags tf , ExtraTflags etf ) : is_target{Yes} , _tflags{tf} , _extra_tflags{etf} {}
	MatchFlags( Dflags df , ExtraDflags edf ) : is_target{No } , _dflags{df} , _extra_dflags{edf} {}
	// accesses
	bool        operator+   () const {                         return is_target!=Maybe ; }
	bool        operator!   () const {                         return !+*this          ; }
	Tflags      tflags      () const { SWEAR(is_target==Yes) ; return _tflags          ; }
	Dflags      dflags      () const { SWEAR(is_target==No ) ; return _dflags          ; }
	ExtraTflags extra_tflags() const { SWEAR(is_target==Yes) ; return _extra_tflags    ; }
	ExtraDflags extra_dflags() const { SWEAR(is_target==No ) ; return _extra_dflags    ; }
	// data
	Bool3 is_target = Maybe ;
private :
	Tflags      _tflags       ; // if  is_target
	Dflags      _dflags       ; // if !is_target
	ExtraTflags _extra_tflags ; // if  is_target
	ExtraDflags _extra_dflags ; // if !is_target
} ;

ENUM_2( AutodepMethod
,	Ld   = LdAudit                  // >=Ld means a lib is pre-loaded (through LD_AUDIT or LD_PRELOAD)
,	Dflt = AutodepMethod::LdPreload // by default, use  a compromize between speed an reliability, might sense HAS_LD_AUDIT and HAS_SECCOMP if necessary
,	None
,	Ptrace
,	LdAudit
,	LdPreload
)

struct JobRpcReply {
	friend ::ostream& operator<<( ::ostream& , JobRpcReply const& ) ;
	using Crc  = Hash::Crc ;
	using Proc = JobProc   ;
	// cxtors & casts
	JobRpcReply(                                                                      ) = default ;
	JobRpcReply( Proc p                                                               ) : proc{p}                                           {                                                       }
	JobRpcReply( Proc p , Bool3                                  o                    ) : proc{p} , ok{o}                                   { SWEAR( proc==Proc::ChkDeps                        ) ; }
	JobRpcReply( Proc p , ::vector<pair<Bool3/*ok*/,Crc>> const& is                   ) : proc{p} ,         dep_infos{is}                   { SWEAR( proc==Proc::DepInfos                       ) ; }
	JobRpcReply( Proc p , ::string                        const& t  , Crc c , Bool3 o ) : proc{p} , ok{o} ,                 txt{t} , crc{c} { SWEAR( proc==Proc::Decode   || proc==Proc::Encode ) ; }
	// services
	template<IsStream S> void serdes(S& s) {
		if (is_base_of_v<::istream,S>) *this = JobRpcReply() ;
		::serdes(s,proc) ;
		switch (proc) {
			case Proc::None     :
			case Proc::End      :                         break ;
			case Proc::DepInfos : ::serdes(s,dep_infos) ; break ;
			case Proc::ChkDeps  : ::serdes(s,ok       ) ; break ;
			case Proc::Decode :
			case Proc::Encode :
				::serdes(s,ok ) ;
				::serdes(s,txt) ;
				::serdes(s,crc) ;
			break ;
			case Proc::Start :
				::serdes(s,addr            ) ;
				::serdes(s,autodep_env     ) ;
				::serdes(s,chroot          ) ;
				::serdes(s,cmd             ) ;
				::serdes(s,cwd_s           ) ;
				::serdes(s,env             ) ;
				::serdes(s,hash_algo       ) ;
				::serdes(s,interpreter     ) ;
				::serdes(s,keep_tmp        ) ;
				::serdes(s,kill_sigs       ) ;
				::serdes(s,live_out        ) ;
				::serdes(s,method          ) ;
				::serdes(s,network_delay   ) ;
				::serdes(s,pre_actions     ) ;
				::serdes(s,remote_admin_dir) ;
				::serdes(s,small_id        ) ;
				::serdes(s,star_matches    ) ;
				::serdes(s,static_deps     ) ;
				::serdes(s,static_matches  ) ;
				::serdes(s,stdin           ) ;
				::serdes(s,stdout          ) ;
				::serdes(s,timeout         ) ;
				::serdes(s,trace_n_jobs    ) ;
				::serdes(s,use_script      ) ;
			break ;
		DF}
	}
	// data
	Proc                      proc             = Proc::None          ;
	in_addr_t                 addr             = 0                   ; // proc == Start                 , the address at which server and subproccesses can contact job_exec
	AutodepEnv                autodep_env      ;                       // proc == Start
	::string                  chroot           ;                       // proc == Start
	::pair_ss/*script,call*/  cmd              ;                       // proc == Start
	::string                  cwd_s            ;                       // proc == Start
	::vmap_ss                 env              ;                       // proc == Start
	Algo                      hash_algo        = Algo::Xxh           ; // proc == Start
	::vector_s                interpreter      ;                       // proc == Start                 , actual interpreter used to execute cmd
	bool                      keep_tmp         = false               ; // proc == Start
	vector<uint8_t>           kill_sigs        ;                       // proc == Start
	bool                      live_out         = false               ; // proc == Start
	AutodepMethod             method           = AutodepMethod::Dflt ; // proc == Start
	Time::Delay               network_delay    ;                       // proc == Start
	::vmap_s<FileAction>      pre_actions      ;                       // proc == Start
	::string                  remote_admin_dir ;                       // proc == Start
	SmallId                   small_id         = 0                   ; // proc == Start
	::vmap_s<MatchFlags>      star_matches     ;                       // proc == Start                 , maps regexprs to flags
	::vmap_s<DepDigest>       static_deps      ;                       // proc == Start
	::vmap_s<MatchFlags>      static_matches   ;                       // proc == Start
	::string                  stdin            ;                       // proc == Start
	::string                  stdout           ;                       // proc == Start
	Time::Delay               timeout          ;                       // proc == Start
	JobIdx                    trace_n_jobs     = 0                   ; // proc == Start
	bool                      use_script       = false               ; // proc == Start
	::vector<pair<Bool3,Crc>> dep_infos        ;                       // proc == DepInfos
	Bool3                     ok               = Maybe               ; // proc == ChkDeps|Decode|Encode , if No <=> deps in error, if Maybe <=> deps not ready
	::string                  txt              ;                       // proc ==         Decode|Encode , value for Decode, code for Encode
	Crc                       crc              ;                       // proc ==         Decode|Encode , crc of txt
} ;

ENUM_1( JobExecRpcProc
,	HasFiles = Access  // >=HasFiles means files field is significative
,	None
,	ChkDeps
,	CriticalBarrier
,	Tmp                // write activity in tmp has been detected (hence clean up is required)
,	Trace              // no algorithmic info, just for tracing purpose
,	Panic              // ensure job is in error
,	Confirm
,	Access
,	Decode
,	DepInfos
,	Encode
,	Guard
)

// model is : first read , first write , last write
ENUM_1( AccessOrder
,	Write = InbetweenWrites // >=Write means access comes after first write
,	Before
,	BetweenReadAndWrite
,	InbetweenWrites
,	After
)

struct AccessDigest : DepDigest {                                      // order is first read, first write, last write, unlink
	friend ::ostream& operator<<( ::ostream& , AccessDigest const& ) ;
	// cxtors & casts
	AccessDigest() = default ;
	using DepDigest::DepDigest ;
	template<class B2> AccessDigest(DepDigestBase<B2> const& dd) : DepDigest{dd} {}
	// accesses
	bool idle     () const { return !write && !unlink    ; }
	bool operator+() const { return +accesses || !idle() ; }           // true if some access of some sort is done
	bool operator!() const { return +!+*this             ; }
	// services
	bool operator==(AccessDigest const& ad) const = default ;          // XXX : why is this necessary at all ?!?
	AccessDigest operator|(AccessDigest const& ad) const {             // *this, then other
		AccessDigest res = *this ;
		res |= ad ;
		return res ;
	}
	AccessDigest& operator|=(AccessDigest const& ad) {
		update(ad,AccessOrder::After) ;
		return *this ;
	}
	// update this with access from ad, which may be before or after this (or between the read part and the write part is after==Maybe)
	void update( AccessDigest const& , AccessOrder ) ;
	// data
	Tflags      tflags       = {}    ;                                 // dflags are inherited from DepDigest
	ExtraDflags extra_dflags = {}    ;
	ExtraTflags extra_tflags = {}    ;
	bool        write        = false ;                                 // if true <=> files are written, possibly unlinked later
	bool        unlink       = false ;                                 // if true <=> files are unlinked at the end, possibly written before
} ;

struct JobExecRpcReq {
	friend ::ostream& operator<<( ::ostream& , JobExecRpcReq const& ) ;
	// make short lines
	using AD = AccessDigest   ;
	using P  = JobExecRpcProc ;
	using PD = Time::Pdate    ;
	using DD = Time::Ddate    ;
	// statics
private :
	static ::vmap_s<DD> _s_mk_mdd(::vector_s&& fs) { ::vmap_s<DD> res ; for( ::string& f : fs ) res.emplace_back(::move(f),DD()) ; return res ; }
	// cxtors & casts
public :
	JobExecRpcReq(                             ) = default ;
	JobExecRpcReq( P p , bool u , bool ok_     ) : proc{p} , unlink{u} , ok{ok_}      { SWEAR( p==P::Confirm                           ) ; }
	JobExecRpcReq( P p , bool s                ) : proc{p} , sync{s}                  { SWEAR( p<P::HasFiles && p!=P::Confirm          ) ; }
	JobExecRpcReq( P p                         ) : proc{p}                            { SWEAR( p<P::HasFiles && p!=P::Confirm          ) ; }
	JobExecRpcReq( P p , bool s , ::string&& t ) : proc{p} , sync{s} , txt{::move(t)} { SWEAR( p==P::Tmp || p==P::Trace || p==P::Panic ) ; }
	JobExecRpcReq( P p ,          ::string&& t ) : proc{p} ,           txt{::move(t)} { SWEAR( p==P::Tmp || p==P::Trace || p==P::Panic ) ; }
	//
private :
	JobExecRpcReq( P p , bool ad , ::string&& cwd_ , ::vmap_s<DD>&& fs , AccessDigest const& d , bool nf , bool s , bool ok_ , ::string const& comment ) :
		proc     { p            }
	,	sync     { s            }
	,	auto_date{ ad           }
	,	no_follow{ nf           }
	,	ok       { ok_          }
	,	cwd      { ::move(cwd_) }
	,	files    { ::move(fs)   }
	,	digest   { d            }
	,	txt      { comment      }
	{ SWEAR( p==P::Access || p==P::DepInfos ) ; }
public : //!                                                                                                                  auto_date    cwd                              no_follow sync  ok
	JobExecRpcReq( P p , ::vmap_s<DD>&& fs , AD const& ad ,           bool s , bool ok , ::string const& c ) : JobExecRpcReq{p,false  ,{}         ,          ::move(fs) ,ad,false  ,s    ,ok   ,c} {}
	JobExecRpcReq( P p , ::vmap_s<DD>&& fs , AD const& ad ,           bool s ,           ::string const& c ) : JobExecRpcReq{p,false  ,{}         ,          ::move(fs) ,ad,false  ,s    ,false,c} {}
	JobExecRpcReq( P p , ::vmap_s<DD>&& fs , AD const& ad ,                              ::string const& c ) : JobExecRpcReq{p,false  ,{}         ,          ::move(fs) ,ad,false  ,false,false,c} {}
	JobExecRpcReq( P p , ::vector_s  && fs , AD const& ad , bool nf , bool s , bool ok , ::string const& c ) : JobExecRpcReq{p,true   ,Disk::cwd(),_s_mk_mdd(::move(fs)),ad,nf     ,s    ,ok   ,c} {}
	JobExecRpcReq( P p , ::vector_s  && fs , AD const& ad , bool nf , bool s ,           ::string const& c ) : JobExecRpcReq{p,true   ,Disk::cwd(),_s_mk_mdd(::move(fs)),ad,nf     ,s    ,false,c} {}
	JobExecRpcReq( P p , ::vector_s  && fs , AD const& ad , bool nf ,                    ::string const& c ) : JobExecRpcReq{p,true   ,Disk::cwd(),_s_mk_mdd(::move(fs)),ad,nf     ,false,false,c} {}
	//
	JobExecRpcReq( P p , ::vector_s&& fs , ::string&& c={} ) : proc{p} , files{_s_mk_mdd(::move(fs))} , txt{::move(c)} { SWEAR(p==P::Guard) ; }
	//
	JobExecRpcReq( P p , ::string&& f , ::string&& code , ::string&& c ) :
		proc      { p                }
	,	sync      { true             }
	,	auto_date { true             }
	,	cwd       { Disk::cwd()      }
	,	files     { {{::move(f),{}}} }                   // no need for date for codec
	,	digest    { Access::Reg      }
	,	txt       { code             }
	,	ctx       { c                }
	{ SWEAR(p==P::Decode) ; }
	JobExecRpcReq( P p , ::string&& f , ::string&& val , ::string&& c , uint8_t ml ) :
		proc      { p                }
	,	sync      { true             }
	,	auto_date { true             }
	,	min_len   { ml               }
	,	cwd       { Disk::cwd()      }
	,	files     { {{::move(f),{}}} }                   // no need for date for codec
	,	digest    { Access::Reg      }
	,	txt       { val              }
	,	ctx       { c                }
	{ SWEAR(p==P::Encode) ; }
	// services
public :
	template<IsStream T> void serdes(T& s) {
		if (::is_base_of_v<::istream,T>) *this = {} ;
		::serdes(s,proc) ;
		::serdes(s,date) ;
		::serdes(s,sync) ;
		if (proc>=P::HasFiles) {
			::serdes(s,auto_date) ;
			::serdes(s,files    ) ;
			if (auto_date) {
				::serdes(s,cwd      ) ;
				::serdes(s,no_follow) ;
			}
		}
		switch (proc) {
			case P::Confirm  : ::serdes(s,unlink ) ; ::serdes(s,ok ) ; break           ;
			case P::Guard    :
			case P::Tmp      :
			case P::Trace    :
			case P::Panic    :                       ::serdes(s,txt) ; break           ;
			case P::Access   : ::serdes(s,ok     ) ; ::serdes(s,txt) ; [[fallthrough]] ;
			case P::DepInfos : ::serdes(s,digest ) ;                   break           ;
			case P::Encode   : ::serdes(s,min_len) ;                   [[fallthrough]] ;
			case P::Decode   : ::serdes(s,ctx    ) ; ::serdes(s,txt) ; break           ;
			default : ;
		}
	}
	// data
	P            proc      = P::None                   ;
	bool         sync      = false                     ;
	bool         auto_date = false                     ; // if proc>=HasFiles, if true <=> files must be solved and dates added by probing disk
	bool         no_follow = false                     ; // if auto_date, whether links should not be followed
	bool         unlink    = false                     ; // if proc==       Confirm
	bool         ok        = false                     ; // if proc==Access|Confirm, declare target (Access) or confirm access (Confirm)
	uint8_t      min_len   = 0                         ; // if proc==Encode
	PD           date      = PD::s_now()               ; // access date to reorder accesses during analysis
	::string     cwd       ;                             // if auto_date, cwd to use to solve files
	::vmap_s<DD> files     ;
	AccessDigest digest    ;
	::string     txt       ;                             // if proc==Access|Decode|Encode|Trace (comment for Access, code for Decode, value for Encode)
	::string     ctx       ;                             // if proc==Decode|Encode
} ;

struct JobExecRpcReply {
	friend ::ostream& operator<<( ::ostream& , JobExecRpcReply const& ) ;
	using Proc = JobExecRpcProc ;
	using Crc  = Hash::Crc      ;
	// cxtors & casts
	JobExecRpcReply(                                                    ) = default ;
	JobExecRpcReply( Proc p                                             ) : proc{p}                 { SWEAR( proc!=Proc::ChkDeps && proc!=Proc::DepInfos ) ; }
	JobExecRpcReply( Proc p , Bool3 o                                   ) : proc{p} , ok       {o } { SWEAR( proc==Proc::ChkDeps                         ) ; }
	JobExecRpcReply( Proc p , ::vector<pair<Bool3/*ok*/,Crc>> const& is ) : proc{p} , dep_infos{is} { SWEAR( proc==Proc::DepInfos                        ) ; }
	JobExecRpcReply( Proc p , ::string const&                        t  ) : proc{p} , txt      {t } { SWEAR( proc==Proc::Decode  || proc==Proc::Encode   ) ; }
	//
	JobExecRpcReply( JobRpcReply const& jrr ) ;
	// services
	template<IsStream S> void serdes(S& s) {
		if (::is_base_of_v<::istream,S>) *this = JobExecRpcReply() ;
		::serdes(s,proc) ;
		switch (proc) {
			case Proc::Access   :                         break ;
			case Proc::ChkDeps  : ::serdes(s,ok       ) ; break ;
			case Proc::DepInfos : ::serdes(s,dep_infos) ; break ;
			case Proc::Decode :
			case Proc::Encode :
				::serdes(s,ok ) ;
				::serdes(s,txt) ;
			break ;
		DF}
	}
	// data
	Proc                            proc      = Proc::None ;
	Bool3                           ok        = Maybe      ; // if proc==ChkDeps
	::vector<pair<Bool3/*ok*/,Crc>> dep_infos ;              // if proc==DepInfos
	::string                        txt       ;              // if proc==Decode|Encode (value for Decode, code for Encode)
} ;

//
// JobSserverRpcReq
//

ENUM( JobServerRpcProc
,	Heartbeat
,	Kill
)

struct JobServerRpcReq {
	friend ::ostream& operator<<( ::ostream& , JobServerRpcReq const& ) ;
	using Proc = JobServerRpcProc ;
	// cxtors & casts
	JobServerRpcReq(                              ) = default ;
	JobServerRpcReq( Proc p , SeqId si            ) : proc{p} , seq_id{si}          { SWEAR(proc==Proc::Kill     ) ; }
	JobServerRpcReq( Proc p , SeqId si , JobIdx j ) : proc{p} , seq_id{si} , job{j} {                                } // need a job for heartbeat as we may have to reply on its behalf
	// services
	template<IsStream S> void serdes(S& s) {
		::serdes(s,proc  ) ;
		::serdes(s,seq_id) ;
		switch (proc) {
			case Proc::Heartbeat : ::serdes(s,job) ;                          break ;
			case Proc::Kill      : if (::is_base_of_v<::istream,S>) job = 0 ; break ;
		DF}
	}
	// data
	Proc   proc   = {} ;
	SeqId  seq_id = 0  ;
	JobIdx job    = 0  ;
} ;

struct JobInfoStart {
	friend ::ostream& operator<<( ::ostream& , JobInfoStart const& ) ;
	// data
	Hash::Crc   rule_cmd_crc = {}         ;
	::vector_s  stems        = {}         ;
	Time::Pdate eta          = {}         ;
	SubmitAttrs submit_attrs = {}         ;
	::vmap_ss   rsrcs        = {}         ;
	in_addr_t   host         = NoSockAddr ;
	JobRpcReq   pre_start    = {}         ;
	JobRpcReply start        = {}         ;
	::string    stderr       = {}         ;
} ;

struct JobInfoEnd {
	friend ::ostream& operator<<( ::ostream& , JobInfoEnd const& ) ;
	// data
	JobRpcReq end = {} ;
} ;

//
// codec
//

namespace Codec {

	static constexpr char CodecPfx[] = ADMIN_DIR "/codec/" ;

	::string mk_decode_node( ::string const& file , ::string const& ctx , ::string const& code ) ;
	::string mk_encode_node( ::string const& file , ::string const& ctx , ::string const& val  ) ;

	::string mk_file(::string const& node) ; // node may have been obtained from mk_decode_node or mk_encode_node

}
